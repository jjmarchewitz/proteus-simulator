This simulator is divided up into two main components: the LCD simulator and the robot simulator

This document is about the implementation details of the simulator, not what the proteus classes are designed to do.  For that information, see the FEH Proteus website at: https://u.osu.edu/fehproteus/

## Overall Structure
The entry point of the code is located in FEHMain.cpp in the libraries folder.  This function's only duty is to create a new thread for proteus main using ThreadProteus.  The ThreadProteus function is declared in FEHThread.h and defined in FEHThread.cpp.  Because Window's mingw32 and MacOS's XTools use different thread functions, the implementation details of ThreadProteus and the FEHMutex class are different, but they still have the same functionality.  Both implementations create a new thread of ProteusMain located in main.cpp and the main thread in both implementations enter into a rendering loop updating the LCD screen and the dashboard's screen.  Students will still edit main.cpp, but instead of editing the main function they will edit the ProteusMain function defined in that file.  The reason main is hidden from students like this is because if the screen is updated in a thread that is not the main thread, the program will crash on Macs.  To make sure that students do not need to insert code updating the screen in their robot or SDP code, the main thread is used to create the student's thread and update the two screen.
#
## FEHLCD
The FEHLCD.h class is implemented using the tigr graphics library found in tigr.c and tigr.h.  Because the Proteus' screen has drawn objects wrapped around the screen, the functions in FEHLCD that draw shapes all call LCD.DrawPixel().  The DrawPixel edits the given coordinates to ensure that the pixels are drawn within the bounds of the Proteus screen.
To draw fonts, FEHLCD.cpp has a bitmap named fontData that contains pixel mapping for every character that the Proteus supports.  The WriteCharAt function uses the bitmap of the character it is given to draw the character.  It contains two for loops that loop through the 5x7 pixel data to determing where to draw each pixel.  Other writing functions like WriteAt and WriteLine repeatedly call WriteCharAt to draw strings.
LCD.Update must be called in order for the drawn shapes to appear, but students will not need to call that because updating the screen is handled by the main thread.
#
## The Robot Simulator
The robot simulator displays a visual representation of the state of any motors, servos, or pins that students can connect to the Proteus.  From the student's perspective, the code will look exactly the same as on the actual proteus.
All robot components (i.e. FEHMotor) inherit from the Component class in Component.h.  This class only has a constructor and a pure virtual function Draw that is called to draw the component on the dashboard.  When a robot component is created, the Component's constructor adds itself to a vector of Component pointers in the FEHDashboard class.
The FEHDashboard class controls the overall logic for this part of the simulator. FEHDashboard.cpp contains a global Dashboard variable that is referenced throughout the repository.  It contains a vector of all the robot components that it cycles through in its Update function to draw each component to the screen.  Components in the vector are edited by the students' robot code in the second thread while the Components are alse used by the main thread to draw them to the screen.  Because of this, the dashMutex variable from FEHDashboard.cpp is used to ensure that the components remain thread safe.  Not locking and unlocking the mutex lock before and after using the dashboard's screen can crash the program.  The original plan was to have a mutex variable inside of the Component class for editing component specific data, but having a mutex there would crash the program on Macs and is currently untested in Windows.